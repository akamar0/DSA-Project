#include <iostream>
#include <stack>
#include <queue>
#include <string>
#include <limits> // Used for numeric_limits to clear cin

using namespace std;

// --- 1. Data Structures Definition ---

// Node for the main playlist (Singly Linked List)
struct SongNode {
    string title;
    string artist;
    SongNode* next;

    // Constructor for cleaner initialization
    SongNode(const string& t, const string& a) 
        : title(t), artist(a), next(nullptr) {}
};

// --- 2. Playlist Manager Class ---
class MusicPlayerManager {
private:
    // The main list of available songs (Singly Linked List)
    SongNode* mainPlaylistHead; 

    // Songs scheduled to play next (Queue - FIFO)
    queue<SongNode*> playQueue; 

    // History of played songs (Stack - LIFO)
    stack<SongNode*> playbackHistory; 

    // The song currently playing
    SongNode* currentSong; 

public:
    // Constructor to initialize pointers
    MusicPlayerManager() : mainPlaylistHead(nullptr), currentSong(nullptr) {}

    // Destructor (important to free memory from the linked list)
    ~MusicPlayerManager() {
        SongNode* current = mainPlaylistHead;
        SongNode* nextNode;
        while (current != nullptr) {
            nextNode = current->next;
            delete current;
            current = nextNode;
        }
    }

    // --- Core Linked List Operations ---

    // 1. Add song at end of main playlist (O(N) operation)
    void addSongToPlaylist(const string& title, const string& artist) {
        SongNode* newSong = new SongNode(title, artist);

        if (!mainPlaylistHead) {
            mainPlaylistHead = newSong;
        } else {
            SongNode* temp = mainPlaylistHead;
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = newSong;
        }
        cout << "[SUCCESS] Song '" << title << "' added to the main playlist.\n";
    }

    // Helper to find a song by title (O(N) operation)
    SongNode* findSongNode(const string& title) const {
        SongNode* temp = mainPlaylistHead;
        while (temp != nullptr) {
            if (temp->title == title) {
                return temp;
            }
            temp = temp->next;
        }
        return nullptr;
    }

    // 2. Display main playlist
    void displayMainPlaylist() const {
        if (!mainPlaylistHead) {
            cout << "\n--- PLAYLIST ---\nPlaylist is empty.\n-----------------\n";
            return;
        }

        cout << "\n--- PLAYLIST ---\n";
        SongNode* temp = mainPlaylistHead;
        int num = 1;
        while (temp != nullptr) {
            cout << num++ << ". " << temp->title << " - " << temp->artist << endl;
            temp = temp->next;
        }
        cout << "-----------------\n";
    }

    // --- Queue & Stack Operations ---

    // 3. Add song to play queue (Queue: ENQUEUE)
    void queueNextSong(const string& title) {
        SongNode* songToQueue = findSongNode(title);
        
        if (songToQueue) {
            playQueue.push(songToQueue);
            cout << "[SUCCESS] '" << songToQueue->title << "' added to play queue (FIFO).\n";
        } else {
            cout << "[ERROR] Song '" << title << "' not found in the main playlist.\n";
        }
    }

    // 4. Play the next song (Queue: DEQUEUE, Stack: PUSH)
    void playNextSong() {
        if (playQueue.empty()) {
            cout << "[INFO] Play queue is empty. Cannot play next.\n";
            return;
        }

        // 1. If there's a current song, push it to history (Stack: PUSH)
        if (currentSong) {
            playbackHistory.push(currentSong);
        }

        // 2. Get the next song from the queue (Queue: FRONT & POP)
        currentSong = playQueue.front();
        playQueue.pop();

        cout << "\n>>> NOW PLAYING: " << currentSong->title << " - " << currentSong->artist << endl;
    }

    // 5. Play the previous song (Stack: POP, Queue: PUSH)
    void playPreviousSong() {
        if (playbackHistory.empty()) {
            cout << "[INFO] No previous song in history (LIFO).\n";
            return;
        }

        // 1. Put the CURRENT song back onto the play queue (Queue: PUSH)
        // This is a common way to handle 'go back' so the user can return to the current point.
        if (currentSong) {
            playQueue.push(currentSong);
        }

        // 2. Get the previous song from history (Stack: TOP & POP)
        currentSong = playbackHistory.top();
        playbackHistory.pop();

        cout << "\n<<< PREVIOUS SONG: " << currentSong->title << " - " << currentSong->artist << endl;
    }

    // 6. Show the currently playing song
    void showCurrentSong() const {
        if (currentSong) {
            cout << "\nCurrent song: " << currentSong->title << " - " << currentSong->artist << endl;
        } else {
            cout << "\nNo song is currently playing.\n";
        }
    }

    // 7. Display Queue Status
    void displayQueueStatus() const {
        cout << "\n--- QUEUE STATUS ---\n";
        cout << "Songs waiting in Queue: " << playQueue.size() << endl;
        if (!playQueue.empty()) {
             cout << "Next song to play: " << playQueue.front()->title << endl;
        }
        cout << "Songs in History (Stack): " << playbackHistory.size() << endl;
        if (!playbackHistory.empty()) {
             cout << "Last played song: " << playbackHistory.top()->title << endl;
        }
        cout << "--------------------\n";
    }

    // --- Menu Handling ---
    void runMenu() {
        int choice;
        string title, artist;

        do {
            // Display the current status before the menu
            showCurrentSong();
            displayQueueStatus();

            cout << "\n=== MUSIC PLAYER MENU ===\n";
            cout << "1. Add Song to Playlist\n";
            cout << "2. Display Main Playlist\n";
            cout << "3. Add Song to Queue (UP NEXT)\n";
            cout << "4. Play Next Song\n";
            cout << "5. Play Previous Song\n";
            cout << "6. Exit\n";
            cout << "Choose: ";
            
            // Input choice with basic error handling
            if (!(cin >> choice)) {
                cout << "[ERROR] Invalid input. Please enter a number.\n";
                cin.clear(); // Clear error flags
                cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Discard bad input
                continue;
            }
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Clear the newline character

            switch (choice) {
                case 1: 
                    cout << "Enter song title: ";
                    getline(cin, title);
                    cout << "Enter artist: ";
                    getline(cin, artist);
                    addSongToPlaylist(title, artist);
                    break;
                case 2:
                    displayMainPlaylist();
                    break;
                case 3: 
                    cout << "Enter song title to queue: ";
                    getline(cin, title);
                    queueNextSong(title);
                    break;
                case 4: 
                    playNextSong();
                    break;
                case 5: 
                    playPreviousSong();
                    break;
                case 6:
                    cout << "Exiting Music Player. Goodbye!\n";
                    break;
                default:
                    cout << "[ERROR] Invalid choice. Please select an option from 1 to 6.\n";
            }
        } while (choice != 6);
    }
};

// --- 3. Main Program Execution ---
int main() {
    MusicPlayerManager player;
    player.runMenu();
    return 0;
}